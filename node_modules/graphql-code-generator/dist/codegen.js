"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var Listr = require("listr");
var helpers_1 = require("./helpers");
var prettier_1 = require("./utils/prettier");
var listr_renderer_1 = require("./utils/listr-renderer");
var errors_1 = require("./errors");
var load_1 = require("./load");
var merge_schemas_1 = require("./merge-schemas");
var graphql_1 = require("graphql");
var execute_plugin_1 = require("./execute-plugin");
function executeCodegen(config) {
    return __awaiter(this, void 0, void 0, function () {
        function wrapTask(task, source) {
            var _this = this;
            return function () { return __awaiter(_this, void 0, void 0, function () {
                var error_1;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            _a.trys.push([0, 2, , 3]);
                            return [4 /*yield*/, task()];
                        case 1:
                            _a.sent();
                            return [3 /*break*/, 3];
                        case 2:
                            error_1 = _a.sent();
                            if (source && !(error_1 instanceof graphql_1.GraphQLError)) {
                                error_1.source = source;
                            }
                            throw error_1;
                        case 3: return [2 /*return*/];
                    }
                });
            }); };
        }
        function normalize() {
            /* Load Require extensions */
            var requireExtensions = helpers_1.normalizeInstanceOrArray(config.require);
            requireExtensions.forEach(function (mod) { return require(mod); });
            /* Root templates-config */
            rootConfig = config.config || {};
            /* Normalize root "schema" field */
            rootSchemas = helpers_1.normalizeInstanceOrArray(config.schema);
            /* Normalize root "documents" field */
            rootDocuments = helpers_1.normalizeInstanceOrArray(config.documents);
            /* Normalize "generators" field */
            var generateKeys = Object.keys(config.generates);
            if (generateKeys.length === 0) {
                throw new errors_1.DetailedError('Invalid Codegen Configuration!', "\n        Please make sure that your codegen config file contains the \"generates\" field, with a specification for the plugins you need.\n        \n        It should looks like that:\n\n        schema:\n          - my-schema.graphql\n        generates:\n          my-file.ts:\n            - plugin1\n            - plugin2\n            - plugin3\n        ");
            }
            for (var _i = 0, generateKeys_1 = generateKeys; _i < generateKeys_1.length; _i++) {
                var filename = generateKeys_1[_i];
                generates[filename] = helpers_1.normalizeOutputParam(config.generates[filename]);
                if (generates[filename].plugins.length === 0) {
                    throw new errors_1.DetailedError('Invalid Codegen Configuration!', "\n          Please make sure that your codegen config file has defined plugins list for output \"" + filename + "\".\n          \n          It should looks like that:\n  \n          schema:\n            - my-schema.graphql\n          generates:\n            my-file.ts:\n              - plugin1\n              - plugin2\n              - plugin3\n          ");
                }
            }
            if (rootSchemas.length === 0 && Object.keys(generates).some(function (filename) { return generates[filename].schema.length === 0; })) {
                throw new errors_1.DetailedError('Invalid Codegen Configuration!', "\n        Please make sure that your codegen config file contains either the \"schema\" field \n        or every generated file has its own \"schema\" field.\n        \n        It should looks like that:\n        schema:\n          - my-schema.graphql\n\n        or:\n        generates:\n          path/to/output:\n            schema: my-schema.graphql\n      ");
            }
        }
        var result, commonListrOptions, listr, rootConfig, rootSchemas, rootDocuments, generates;
        var _this = this;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    result = [];
                    commonListrOptions = {
                        exitOnError: true
                    };
                    if (process.env.VERBOSE) {
                        listr = new Listr(__assign({}, commonListrOptions, { renderer: 'verbose', nonTTYRenderer: 'verbose' }));
                    }
                    else if (process.env.NODE_ENV === 'test') {
                        listr = new Listr(__assign({}, commonListrOptions, { renderer: 'silent', nonTTYRenderer: 'silent' }));
                    }
                    else {
                        listr = new Listr(__assign({}, commonListrOptions, { renderer: config.silent ? 'silent' : listr_renderer_1.Renderer, nonTTYRenderer: config.silent ? 'silent' : 'default', collapse: true, clearOutput: false }));
                    }
                    rootConfig = {};
                    generates = {};
                    listr.add({
                        title: 'Parse configuration',
                        task: function () { return normalize(); }
                    });
                    listr.add({
                        title: 'Generate outputs',
                        task: function () {
                            return new Listr(Object.keys(generates).map(function (filename, i) { return ({
                                title: "Generate " + filename,
                                task: function () {
                                    var outputConfig = generates[filename];
                                    var outputFileTemplateConfig = outputConfig.config || {};
                                    var outputDocuments = [];
                                    var outputSchema;
                                    var outputSpecificSchemas = helpers_1.normalizeInstanceOrArray(outputConfig.schema);
                                    var outputSpecificDocuments = helpers_1.normalizeInstanceOrArray(outputConfig.documents);
                                    return new Listr([
                                        {
                                            title: 'Load GraphQL schemas',
                                            task: wrapTask(function () { return __awaiter(_this, void 0, void 0, function () {
                                                var allSchemas, _a;
                                                return __generator(this, function (_b) {
                                                    switch (_b.label) {
                                                        case 0:
                                                            allSchemas = rootSchemas.map(function (pointToScehma) { return load_1.loadSchema(pointToScehma, config); }).concat(outputSpecificSchemas.map(function (pointToScehma) { return load_1.loadSchema(pointToScehma, config); }));
                                                            if (!(allSchemas.length > 0)) return [3 /*break*/, 3];
                                                            _a = merge_schemas_1.mergeSchemas;
                                                            return [4 /*yield*/, Promise.all(allSchemas)];
                                                        case 1: return [4 /*yield*/, _a.apply(void 0, [_b.sent()])];
                                                        case 2:
                                                            outputSchema = _b.sent();
                                                            _b.label = 3;
                                                        case 3: return [2 /*return*/];
                                                    }
                                                });
                                            }); }, filename)
                                        },
                                        {
                                            title: 'Load GraphQL documents',
                                            task: wrapTask(function () { return __awaiter(_this, void 0, void 0, function () {
                                                var allDocuments, _i, allDocuments_1, docDef, documents;
                                                return __generator(this, function (_a) {
                                                    switch (_a.label) {
                                                        case 0:
                                                            allDocuments = rootDocuments.concat(outputSpecificDocuments);
                                                            _i = 0, allDocuments_1 = allDocuments;
                                                            _a.label = 1;
                                                        case 1:
                                                            if (!(_i < allDocuments_1.length)) return [3 /*break*/, 4];
                                                            docDef = allDocuments_1[_i];
                                                            return [4 /*yield*/, load_1.loadDocuments(docDef, config)];
                                                        case 2:
                                                            documents = _a.sent();
                                                            if (documents.length > 0) {
                                                                outputDocuments.push.apply(outputDocuments, documents);
                                                            }
                                                            _a.label = 3;
                                                        case 3:
                                                            _i++;
                                                            return [3 /*break*/, 1];
                                                        case 4: return [2 /*return*/];
                                                    }
                                                });
                                            }); }, filename)
                                        },
                                        {
                                            title: 'Generate',
                                            task: wrapTask(function () { return __awaiter(_this, void 0, void 0, function () {
                                                var normalizedPluginsArray, output;
                                                return __generator(this, function (_a) {
                                                    switch (_a.label) {
                                                        case 0:
                                                            normalizedPluginsArray = helpers_1.normalizeConfig(outputConfig.plugins);
                                                            return [4 /*yield*/, generateOutput({
                                                                    filename: filename,
                                                                    plugins: normalizedPluginsArray,
                                                                    schema: outputSchema,
                                                                    documents: outputDocuments,
                                                                    inheritedConfig: __assign({}, rootConfig, outputFileTemplateConfig),
                                                                    pluginLoader: config.pluginLoader || require
                                                                })];
                                                        case 1:
                                                            output = _a.sent();
                                                            result.push(output);
                                                            return [2 /*return*/];
                                                    }
                                                });
                                            }); }, filename)
                                        }
                                    ], {
                                        // it stops when one of tasks failed
                                        exitOnError: true
                                    });
                                }
                            }); }), {
                                // it doesn't stop when one of tasks failed, to finish at least some of outputs
                                exitOnError: false,
                                // run 4 at once
                                concurrent: 4
                            });
                        }
                    });
                    return [4 /*yield*/, listr.run()];
                case 1:
                    _a.sent();
                    return [2 /*return*/, result];
            }
        });
    });
}
exports.executeCodegen = executeCodegen;
function validateDocuments(schema, files) {
    // duplicated names
    var operationMap = {};
    files.forEach(function (file) {
        graphql_1.visit(file.content, {
            OperationDefinition: function (node) {
                if (typeof node.name !== 'undefined') {
                    if (!operationMap[node.name.value]) {
                        operationMap[node.name.value] = [];
                    }
                    operationMap[node.name.value].push(file.filePath);
                }
            }
        });
    });
    var names = Object.keys(operationMap);
    if (names.length) {
        var duplicated = names.filter(function (name) { return operationMap[name].length > 1; });
        if (!duplicated.length) {
            return;
        }
        var list = duplicated
            .map(function (name) {
            return ("\n      * " + name + " found in:\n        " + operationMap[name]
                .map(function (filepath) {
                return ("\n            - " + filepath + "\n          ").trimRight();
            })
                .join('') + "\n  ").trimRight();
        })
            .join('');
        throw new errors_1.DetailedError("Not all operations have an unique name: " + duplicated.join(', '), "\n        Not all operations have an unique name\n\n        " + list + "\n      ");
    }
}
function generateOutput(options) {
    return __awaiter(this, void 0, void 0, function () {
        var output, pluginsPackages, schema, i, plugin, pluginPackage, name_1, pluginConfig, result, _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    output = '';
                    validateDocuments(options.schema, options.documents);
                    return [4 /*yield*/, Promise.all(options.plugins.map(function (plugin) { return execute_plugin_1.getPluginByName(Object.keys(plugin)[0], options.pluginLoader); }))];
                case 1:
                    pluginsPackages = _b.sent();
                    schema = pluginsPackages.reduce(function (schema, plugin) {
                        return !plugin.addToSchema ? schema : merge_schemas_1.mergeSchemas([schema, plugin.addToSchema]);
                    }, options.schema);
                    i = 0;
                    _b.label = 2;
                case 2:
                    if (!(i < options.plugins.length)) return [3 /*break*/, 5];
                    plugin = options.plugins[i];
                    pluginPackage = pluginsPackages[i];
                    name_1 = Object.keys(plugin)[0];
                    pluginConfig = plugin[name_1];
                    return [4 /*yield*/, execute_plugin_1.executePlugin({
                            name: name_1,
                            config: typeof pluginConfig !== 'object'
                                ? pluginConfig
                                : __assign({}, options.inheritedConfig, pluginConfig),
                            schema: schema,
                            documents: options.documents,
                            outputFilename: options.filename,
                            allPlugins: options.plugins
                        }, pluginPackage)];
                case 3:
                    result = _b.sent();
                    output += result;
                    _b.label = 4;
                case 4:
                    i++;
                    return [3 /*break*/, 2];
                case 5:
                    _a = { filename: options.filename };
                    return [4 /*yield*/, prettier_1.prettify(options.filename, output)];
                case 6: return [2 /*return*/, (_a.content = _b.sent(), _a)];
            }
        });
    });
}
exports.generateOutput = generateOutput;
//# sourceMappingURL=codegen.js.map